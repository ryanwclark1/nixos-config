// =============================================================================
// LOKI CONFIGURATION
// =============================================================================

// Loki write component for sending logs to Loki with retry and timeout
loki.write "local" {
  endpoint {
    url = "http://woody:3100/loki/api/v1/push"
    timeout = "10s"
    retry_on_failure {
      enabled = true
      initial_delay = "1s"
      max_delay = "30s"
      max_retries = 10
    }
  }
  external_labels = {
    "host" = "woody"
    "component" = "alloy"
    "environment" = "production"
  }
}

// =============================================================================
// PROMETHEUS CONFIGURATION
// =============================================================================

// Prometheus remote write for metrics with retry and timeout
prometheus.remote_write "local" {
  endpoint {
    url = "http://woody:9090/api/v1/write"
    timeout = "10s"
    retry_on_failure {
      enabled = true
      initial_delay = "1s"
      max_delay = "30s"
      max_retries = 10
    }
  }
  external_labels = {
    "host" = "woody"
    "component" = "alloy"
    "environment" = "production"
  }
}

// =============================================================================
// RELABELING RULES
// =============================================================================

// Enhanced relabel rules for journal logs
loki.relabel "journal" {
  forward_to = []

  rule {
    source_labels = ["__journal__systemd_unit"]
    target_label  = "unit"
  }
  rule {
    source_labels = ["__journal__boot_id"]
    target_label  = "boot_id"
  }
  rule {
    source_labels = ["__journal__transport"]
    target_label  = "transport"
  }
  rule {
    source_labels = ["__journal_priority_keyword"]
    target_label  = "level"
  }
  rule {
    source_labels = ["__journal__hostname"]
    target_label  = "instance"
  }
  rule {
    source_labels = ["__journal__machine_id"]
    target_label  = "machine_id"
  }
  rule {
    source_labels = ["__journal__user_id"]
    target_label  = "user_id"
  }
  rule {
    source_labels = ["__journal__user_name"]
    target_label  = "user_name"
  }
  rule {
    source_labels = ["__journal__session_id"]
    target_label  = "session_id"
  }
  rule {
    source_labels = ["__journal__slice"]
    target_label  = "slice"
  }
  rule {
    source_labels = ["__journal__invocation_id"]
    target_label  = "invocation_id"
  }
  rule {
    source_labels = ["__journal__message_id"]
    target_label  = "message_id"
  }
  rule {
    source_labels = ["__journal__cursor"]
    target_label  = "cursor"
  }
  rule {
    source_labels = ["__journal__realtime_timestamp"]
    target_label  = "realtime_timestamp"
  }
  rule {
    source_labels = ["__journal__monotonic_timestamp"]
    target_label  = "monotonic_timestamp"
  }
}

// Relabel rules for file logs
loki.relabel "file_logs" {
  forward_to = []

  rule {
    source_labels = ["__path__"]
    target_label  = "file_path"
  }
  rule {
    source_labels = ["__filename__"]
    target_label  = "filename"
  }
  rule {
    source_labels = ["__path__"]
    regex = ".*/([^/]+)\\.log"
    target_label  = "service"
    replacement = "$1"
  }
}

// Generic relabel rule to extract log levels from messages
loki.relabel "log_level" {
  forward_to = []

  rule {
    source_labels = ["__raw_log_message__"]
    regex = ".*level=(debug|info|warn|error|fatal).*"
    target_label = "level"
    replacement = "$1"
  }
  rule {
    source_labels = ["__raw_log_message__"]
    regex = ".*severity=(debug|info|warning|error|critical).*"
    target_label = "level"
    replacement = "$1"
  }
  rule {
    source_labels = ["__raw_log_message__"]
    regex = ".*\[(DEBUG|INFO|WARN|ERROR|FATAL)\]:?.*"
    target_label = "level"
    replacement = "$1"
  }
}

// =============================================================================
// LOG SOURCES
// =============================================================================

// Journal source for reading systemd journal logs with enhanced relabeling
loki.source.journal "read" {
  forward_to = [
    loki.write.local.receiver,
  ]
  relabel_rules = [
    loki.relabel.journal.rules,
    loki.relabel.log_level.rules,
  ]
  labels = {
    "job" = "journal",
    "host" = "frametop",
    "component" = "alloy",
    "source" = "systemd-journal",
  }
  // Enhanced journal configuration
  journal {
    json = false
    max_age = "12h"
    path = "/var/log/journal"
    matches = [
      "_SYSTEMD_UNIT=systemd-*",
      "_SYSTEMD_UNIT=*.service",
      "_SYSTEMD_UNIT=*.socket",
      "_SYSTEMD_UNIT=*.timer",
    ]
  }
}

// Enhanced file source patterns for application logs
local.file_match "applogs" {
  path_targets = [
    // System logs
    {"__path__" = "/var/log/*.log"},
    {"__path__" = "/var/log/syslog"},
    {"__path__" = "/var/log/auth.log"},
    {"__path__" = "/var/log/kern.log"},
    {"__path__" = "/var/log/dmesg"},
    {"__path__" = "/var/log/daemon.log"},
    {"__path__" = "/var/log/messages"},

    // Application specific logs
    {"__path__" = "/var/log/postgresql/*.log"},

    // Docker logs
    {"__path__" = "/var/lib/docker/containers/*/*.log"},

    // Custom application logs
    {"__path__" = "/var/log/applications/*.log"},
    {"__path__" = "/opt/*/logs/*.log"},

    // Security logs
    {"__path__" = "/var/log/audit/audit.log"},
    {"__path__" = "/var/log/fail2ban.log"},

    // Network logs
    {"__path__" = "/var/log/ufw.log"},
    {"__path__" = "/var/log/iptables.log"},
  ]
}

// File source for reading application logs with enhanced configuration
loki.source.file "local_files" {
  targets = local.file_match.applogs.targets
  forward_to = [
    loki.write.local.receiver,
  ]
  relabel_rules = [
    loki.relabel.file_logs.rules,
    loki.relabel.log_level.rules,
  ]
  labels = {
    "job" = "varlogs",
    "host" = "frametop",
    "component" = "alloy",
    "source" = "file",
  }
  // Enhanced file reading configuration
  positions_directory = "/var/lib/alloy/positions"
  encoding = "utf-8"
  follow_symlinks = true
  read_from_beginning = false
  // Rate limiting to prevent overwhelming the system
  rate_limiter {
    enabled = true
    rate = 10000
    burst = 20000
  }
}

// Docker container logs source
loki.source.docker "docker" {
  host = "unix:///var/run/docker.sock"
  forward_to = [
    loki.write.local.receiver,
  ]
  relabel_rules = [
    loki.relabel.log_level.rules,
  ]
  labels = {
    "job" = "docker",
    "host" = "frametop",
    "component" = "alloy",
    "source" = "docker",
  }
}

// =============================================================================
// METRICS COLLECTION
// =============================================================================

// Self-monitoring for Alloy health
prometheus.scrape "self" {
  targets = [
    {
      "__address__" = "127.0.0.1:12345",
      "job" = "alloy_self",
    },
  ]
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  scrape_interval = "30s"
  scrape_timeout = "10s"
  honor_labels = true
  honor_timestamps = true
  metrics_path = "/metrics"
  scheme = "http"
}

// Unix exporter for comprehensive system metrics
prometheus.exporter.unix "unix" {
  enabled_collectors = [
    "cpu",
    "diskstats",
    "filesystem",
    "loadavg",
    "meminfo",
    "netdev",
    "netstat",
    "textfile",
    "time",
    "uname",
    "vmstat",
    "logind",
    "interrupts",
    "ksmd",
    "processes",
    "systemd",
    "filefd",
    "hwmon",
    "mountstats",
    "sockstat",
    "stat",
  ]
  filesystem {
    mount_points_exclude = "^/(sys|proc|dev|host|etc)($|/)"
    fs_types_exclude = "^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs)$"
  }
}

prometheus.scrape "unix" {
  targets = prometheus.exporter.unix.unix.targets
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  scrape_interval = "15s"
  scrape_timeout = "10s"
  honor_labels = true
  honor_timestamps = true
  metrics_path = "/metrics"
  scheme = "http"
  labels = {
    "job" = "unix",
  }
}

// Discover all processes
discovery.process "all_processes" {
  procfs = "/proc"
  cgroupfs = "/sys/fs/cgroup"
}

// Filter processes for monitoring
discovery.relabel "filtered_processes" {
  targets = discovery.process.all_processes.targets

  rule {
    action = "keep"
    regex = "^(prometheus|grafana|node_exporter|systemd_exporter|cadvisor|process_exporter)$"
    source_labels = ["__meta_process_name"]
  }
}

// Process exporter for detailed process monitoring
prometheus.exporter.process "process" {
  targets = discovery.relabel.filtered_processes.targets
  procfs = "/proc"
  cgroupfs = "/sys/fs/cgroup"
  smaps = true
  threads = true
  gopsutil = true
}

prometheus.scrape "process" {
  targets = prometheus.exporter.process.process.targets
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  scrape_interval = "15s"
  scrape_timeout = "10s"
  honor_labels = true
  honor_timestamps = true
  metrics_path = "/metrics"
  scheme = "http"
  labels = {
    "job" = "process",
  }
}

// Blackbox exporter for probing endpoints
prometheus.exporter.blackbox "blackbox" {
  config_file = "/etc/alloy/blackbox.yml"
}

prometheus.scrape "blackbox" {
  targets = [
    {"__address__" = "http://prometheus.io", "module" = "http_2xx"},
  ]
  forward_to = [prometheus.remote_write.local.receiver]
  relabel_configs {
    source_labels = ["__address__"]
    target_label = "__param_target"
  }
  relabel_configs {
    source_labels = ["__param_target"]
    target_label = "instance"
  }
  relabel_configs {
    target_label = "__address__"
    replacement = "localhost:9115"
  }
}

// cAdvisor exporter for container metrics
prometheus.exporter.cadvisor "cadvisor" {
}

prometheus.scrape "cadvisor" {
  targets = prometheus.exporter.cadvisor.cadvisor.targets
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  labels = {
    "job" = "cadvisor",
  }
}

// SNMP exporter for network devices
prometheus.exporter.snmp "snmp" {
  config_file = "/etc/alloy/snmp.yml"
}

prometheus.scrape "snmp" {
  targets = [
    {"__address__" = "1.1.1.1", "module" = "default"},
  ]
  forward_to = [prometheus.remote_write.local.receiver]
  relabel_configs {
    source_labels = ["__address__"]
    target_label = "__param_target"
  }
  relabel_configs {
    source_labels = ["__param_target"]
    target_label = "instance"
  }
  relabel_configs {
    target_label = "__address__"
    replacement = "localhost:9116"
  }
}

// Systemd exporter for service monitoring
prometheus.exporter.systemd "systemd" {
  unit_whitelist = [".*"]
  unit_blacklist = [
    "(autovt@|dev-mapper|sys-devices|sys-subsystem|user@|session)\\.(service|socket)"
  ]
  enable_restarts_metrics = true
  enable_start_time_metrics = true
  enable_task_metrics = true
}

prometheus.scrape "systemd" {
  targets = prometheus.exporter.systemd.systemd.targets
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  scrape_interval = "15s"
  scrape_timeout = "10s"
  honor_labels = true
  honor_timestamps = true
  metrics_path = "/metrics"
  scheme = "http"
  labels = {
    "job" = "systemd",
  }
}

// =============================================================================
// LOG PROCESSING AND FILTERING
// =============================================================================

// Log processing pipeline for enhanced log analysis
loki.process "log_processing" {
  forward_to = [loki.write.local.receiver]

  stage.json {
    expressions = {
      level = "level"
      timestamp = "timestamp"
      message = "message"
      service = "service"
      trace_id = "trace_id"
      user_id = "user_id"
      request_id = "request_id"
    }
  }

  stage.labels {
    values = {
      level = ""
      service = ""
      trace_id = ""
      user_id = ""
      request_id = ""
    }
  }

  stage.timestamp {
    source = "timestamp"
    format = "RFC3339Nano"
  }
}

// =============================================================================
// ALERTING AND MONITORING
// =============================================================================

// Self-monitoring for Alloy health
prometheus.scrape "alloy_self" {
  targets = [
    {
      "__address__" = "127.0.0.1:12345",
      "job" = "alloy_self",
    },
  ]
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  scrape_interval = "30s"
  scrape_timeout = "10s"
  honor_labels = true
  honor_timestamps = true
  metrics_path = "/metrics"
  scheme = "http"
}
