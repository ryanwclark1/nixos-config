loki.write "local" {
  endpoint {
    url = "http://woody:3100/loki/api/v1/push"
  }
}

// Relabel rules for file logs
loki.relabel "file_logs" {
  forward_to = []

  rule {
    source_labels = ["__path__"]
    target_label  = "file_path"
  }
  rule {
    source_labels = ["__filename__"]
    target_label  = "filename"
  }
  rule {
    source_labels = ["__path__"]
    regex = ".*/([^/]+)\\.log"
    target_label  = "service"
    replacement = "$1"
  }
}

// Generic relabel rule to extract log levels from messages
loki.relabel "log_level" {
  forward_to = []

  rule {
    source_labels = ["__raw_log_message__"]
    regex = ".*level=(debug|info|warn|error|fatal).*"
    target_label = "level"
    replacement = "$1"
  }
  rule {
    source_labels = ["__raw_log_message__"]
    regex = ".*severity=(debug|info|warning|error|critical).*"
    target_label = "level"
    replacement = "$1"
  }
  rule {
    source_labels = ["__raw_log_message__"]
    regex = ".*\\[(DEBUG|INFO|WARN|ERROR|FATAL)\\]:?.*"
    target_label = "level"
    replacement = "$1"
  }
}

// Journal source for reading systemd journal logs with enhanced relabeling
loki.source.journal "read" {
  forward_to = [
    loki.write.local.receiver,
  ]
  relabel_rules = [
    loki.relabel.journal.rules,
    loki.relabel.log_level.rules,
  ]
  labels = {
    "job" = "journal",
    "host" = "woody",
    "component" = "alloy",
    "source" = "systemd-journal",
  }
  // Enhanced journal configuration
  // journal {
  //   json = false
  //   max_age = "12h"
  //   path = "/var/log/journal"
  //   matches = [
  //     "_SYSTEMD_UNIT=systemd-*",
  //     "_SYSTEMD_UNIT=*.service",
  //     "_SYSTEMD_UNIT=*.socket",
  //     "_SYSTEMD_UNIT=*.timer",
  //   ]
  // }
}

// Enhanced file source patterns for application logs
local.file_match "applogs" {
  path_targets = [
    // System logs
    {"__path__" = "/var/log/*.log"},
    {"__path__" = "/var/log/syslog"},
    {"__path__" = "/var/log/auth.log"},
    {"__path__" = "/var/log/kern.log"},
    {"__path__" = "/var/log/dmesg"},
    {"__path__" = "/var/log/daemon.log"},
    {"__path__" = "/var/log/messages"},

    // Application specific logs
    {"__path__" = "/var/log/postgresql/*.log"},

    // Docker logs
    {"__path__" = "/var/lib/docker/containers/*/*.log"},

    // Custom application logs
    {"__path__" = "/var/log/applications/*.log"},
    {"__path__" = "/opt/*/logs/*.log"},

    // Security logs
    {"__path__" = "/var/log/audit/audit.log"},
    {"__path__" = "/var/log/fail2ban.log"},

    // Network logs
    {"__path__" = "/var/log/ufw.log"},
    {"__path__" = "/var/log/iptables.log"},
  ]
}

// File source for reading application logs with enhanced configuration
loki.source.file "local_files" {
  targets = local.file_match.applogs.targets
  forward_to = [
    loki.write.local.receiver,
  ]
  // relabel_rules = [
  //   loki.relabel.file_logs.rules,
  //   loki.relabel.log_level.rules,
  // ]
  // labels = {
  //   "job" = "varlogs",
  //   "host" = "woody",
  //   "component" = "alloy",
  //   "source" = "file",
  // }
  // Enhanced file reading configuration
  // positions_directory = "/var/lib/alloy/positions"
  // encoding = "utf-8"
  // follow_symlinks = true
  // read_from_beginning = false
  // // Rate limiting to prevent overwhelming the system
  // rate_limiter {
  //   enabled = true
  //   rate = 10000
  //   burst = 20000
  // }
}

// Docker container logs source
loki.source.docker "docker" {
  host = "unix:///var/run/docker.sock"
  forward_to = [
    loki.write.local.receiver,
  ]
  relabel_rules = [
    loki.relabel.log_level.rules,
  ]
  labels = {
    "job" = "docker",
    "host" = "woody",
    "component" = "alloy",
    "source" = "docker",
  }
}

// =============================================================================
// METRICS COLLECTION
// =============================================================================

// Self-monitoring for Alloy health
prometheus.scrape "self" {
  targets = [
    {
      "__address__" = "127.0.0.1:12345",
      "job" = "alloy_self",
    },
  ]
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  scrape_interval = "30s"
  scrape_timeout = "10s"
  honor_labels = true
  honor_timestamps = true
  metrics_path = "/metrics"
  scheme = "http"
}

// Unix exporter for comprehensive system metrics
prometheus.exporter.unix "unix" {
  disable_collectors = [
    "ipvs",
    "infiniband",
    "xfs",
    "zfs",
  ]
  enabled_collectors = [
    "cpu",
    "diskstats",
    "filefd",
    "filesystem",
    "hwmon",
    "interrupts",
    "ksmd",
    "loadavg",
    "logind",
    "meminfo",
    "mountstats",
    "netdev",
    "netstat",
    "processes",
    "sockstat",
    "stat",
    "systemd",
    "textfile",
    "time",
    "uname",
    "vmstat",
  ]
  filesystem {
    // Exclude mount points that aren't relevant for monitoring
    mount_points_exclude = "^/(dev|proc|run/credentials/.+|sys|var/lib/docker/.+)($|/)"
    // Exclude filesystem types that aren't relevant for monitoring
    fs_types_exclude     = "^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|tmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs)$"
    // Timeout for filesystem operations
    mount_timeout        = "5s"
  }
  netclass {
    // Ignore virtual and container network interfaces
    ignored_devices = "^(veth.*|cali.*|[a-f0-9]{15})$"
  }

  netdev {
    // Exclude virtual and container network interfaces from device metrics
    device_exclude = "^(veth.*|cali.*|[a-f0-9]{15})$"
  }
}

prometheus.scrape "unix" {
  targets = prometheus.exporter.unix.unix.targets
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  scrape_interval = "15s"
  scrape_timeout = "10s"
  honor_labels = true
  honor_timestamps = true
  metrics_path = "/metrics"
  scheme = "http"
  labels = {
    "job" = "unix",
  }
}

// Discover all processes
discovery.process "all_processes" {
  procfs = "/proc"
  cgroupfs = "/sys/fs/cgroup"
}

// Filter processes for monitoring
discovery.relabel "filtered_processes" {
  targets = discovery.process.all_processes.targets

  rule {
    action = "keep"
    regex = "^(prometheus|grafana|node_exporter|systemd_exporter|cadvisor|process_exporter)$"
    source_labels = ["__meta_process_name"]
  }
}

// Process exporter for detailed process monitoring
prometheus.exporter.process "process" {
  targets = discovery.relabel.filtered_processes.targets
  procfs = "/proc"
  cgroupfs = "/sys/fs/cgroup"
  smaps = true
  threads = true
  gopsutil = true
}

prometheus.scrape "process" {
  targets = prometheus.exporter.process.process.targets
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  scrape_interval = "15s"
  scrape_timeout = "10s"
  honor_labels = true
  honor_timestamps = true
  metrics_path = "/metrics"
  scheme = "http"
  labels = {
    "job" = "process",
  }
}

// Blackbox exporter for probing endpoints
prometheus.exporter.blackbox "blackbox" {
  config_file = "/etc/alloy/blackbox.yml"
}

prometheus.scrape "blackbox" {
  targets = [
    {"__address__" = "http://prometheus.io", "module" = "http_2xx"},
  ]
  forward_to = [prometheus.remote_write.local.receiver]
  relabel_configs {
    source_labels = ["__address__"]
    target_label = "__param_target"
  }
  relabel_configs {
    source_labels = ["__param_target"]
    target_label = "instance"
  }
  relabel_configs {
    target_label = "__address__"
    replacement = "localhost:9115"
  }
}

// cAdvisor exporter for container metrics
prometheus.exporter.cadvisor "cadvisor" {
  docker_host = "unix:///var/run/docker.sock"
}

prometheus.scrape "cadvisor" {
  targets = prometheus.exporter.cadvisor.cadvisor.targets
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  labels = {
    "job" = "cadvisor",
  }
}

// SNMP exporter for network devices
prometheus.exporter.snmp "snmp" {
  config_file = "/etc/alloy/snmp.yml"
}

prometheus.scrape "snmp" {
  targets = [
    {"__address__" = "1.1.1.1", "module" = "default"},
  ]
  forward_to = [prometheus.remote_write.local.receiver]
  relabel_configs {
    source_labels = ["__address__"]
    target_label = "__param_target"
  }
  relabel_configs {
    source_labels = ["__param_target"]
    target_label = "instance"
  }
  relabel_configs {
    target_label = "__address__"
    replacement = "localhost:9116"
  }
}

// Systemd exporter for service monitoring
prometheus.exporter.systemd "systemd" {
  unit_whitelist = [".*"]
  // unit_blacklist = [
  //   "(autovt@|dev-mapper|sys-devices|sys-subsystem|user@|session)\\.(service|socket)",
  // ]
  enable_restarts_metrics = true
  enable_start_time_metrics = true
  enable_task_metrics = true
}

prometheus.scrape "systemd" {
  targets = prometheus.exporter.systemd.systemd.targets
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  scrape_interval = "15s"
  scrape_timeout = "10s"
  honor_labels = true
  honor_timestamps = true
  metrics_path = "/metrics"
  scheme = "http"
  labels = {
    "job" = "systemd",
  }
}


