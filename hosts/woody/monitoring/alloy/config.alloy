loki.write "local" {
  endpoint {
    url = "http://woody:3100/loki/api/v1/push"
  }
}

// PROMETHEUS CONFIGURATION
// =============================================================================

// Prometheus remote write for metrics with retry and timeout
prometheus.remote_write "local" {
  endpoint {
    url = "http://woody:9090/api/v1/write"
  }
  external_labels = {
    "host" = "woody",
    "component" = "alloy",
    "environment" = "production",
  }
}

// =============================================================================
// RELABELING RULES
// =============================================================================

// Enhanced relabel rules for journal logs
loki.relabel "journal" {
  forward_to = []

  rule {
    source_labels = ["__journal__systemd_unit"]
    target_label  = "unit"
  }
  rule {
    source_labels = ["__journal__boot_id"]
    target_label  = "boot_id"
  }
  rule {
    source_labels = ["__journal__transport"]
    target_label  = "transport"
  }
  rule {
    source_labels = ["__journal_priority_keyword"]
    target_label  = "level"
  }
  rule {
    source_labels = ["__journal__hostname"]
    target_label  = "instance"
  }
  rule {
    source_labels = ["__journal__machine_id"]
    target_label  = "machine_id"
  }
  rule {
    source_labels = ["__journal__user_id"]
    target_label  = "user_id"
  }
  rule {
    source_labels = ["__journal__user_name"]
    target_label  = "user_name"
  }
  rule {
    source_labels = ["__journal__session_id"]
    target_label  = "session_id"
  }
  rule {
    source_labels = ["__journal__slice"]
    target_label  = "slice"
  }
  rule {
    source_labels = ["__journal__invocation_id"]
    target_label  = "invocation_id"
  }
  rule {
    source_labels = ["__journal__message_id"]
    target_label  = "message_id"
  }
  rule {
    source_labels = ["__journal__cursor"]
    target_label  = "cursor"
  }
  rule {
    source_labels = ["__journal__realtime_timestamp"]
    target_label  = "realtime_timestamp"
  }
  rule {
    source_labels = ["__journal__monotonic_timestamp"]
    target_label  = "monotonic_timestamp"
  }
}

// Relabel rules for file logs
loki.relabel "file_logs" {
  forward_to = []

  rule {
    source_labels = ["__path__"]
    target_label  = "file_path"
  }
  rule {
    source_labels = ["__filename__"]
    target_label  = "filename"
  }
  rule {
    source_labels = ["__path__"]
    regex = ".*/([^/]+)\\.log"
    target_label  = "service"
    replacement = "$1"
  }
}

// Generic relabel rule to extract log levels from messages
loki.relabel "log_level" {
  forward_to = []

  rule {
    source_labels = ["__raw_log_message__"]
    regex = ".*level=(debug|info|warn|error|fatal).*"
    target_label = "level"
    replacement = "$1"
  }
  rule {
    source_labels = ["__raw_log_message__"]
    regex = ".*severity=(debug|info|warning|error|critical).*"
    target_label = "level"
    replacement = "$1"
  }
  rule {
    source_labels = ["__raw_log_message__"]
    regex = ".*\\[(DEBUG|INFO|WARN|ERROR|FATAL)\\]:?.*"
    target_label = "level"
    replacement = "$1"
  }
}

// =============================================================================
// LOG SOURCES
// =============================================================================

// Journal source for reading systemd journal logs with enhanced relabeling
loki.source.journal "read" {
  forward_to = [
    loki.write.local.receiver,
  ]
  relabel_rules = [
    loki.relabel.journal.rules,
    loki.relabel.log_level.rules,
  ]
  labels = {
    "job" = "journal",
    "host" = "woody",
    "component" = "alloy",
    "source" = "systemd-journal",
  }
}

// File source for reading application logs with enhanced configuration
loki.source.file "local_files" {
  targets = discovery.relabel.filtered_log_files.targets
  forward_to = [loki.write.local.receiver]
}

// Docker container logs source
loki.source.docker "docker" {
  host = "unix:///var/run/docker.sock"
  targets = []
  forward_to = [
    loki.write.local.receiver,
  ]
  relabel_rules = [
    loki.relabel.log_level.rules,
  ]
  labels = {
    "job" = "docker",
    "host" = "woody",
    "component" = "alloy",
    "source" = "docker",
  }
}

// =============================================================================
// METRICS COLLECTION
// =============================================================================

// Self-monitoring for Alloy health
prometheus.scrape "self" {
  targets = [
    {
      "__address__" = "127.0.0.1:12345",
      "job" = "alloy_self",
    },
  ]
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  scrape_interval = "30s"
  scrape_timeout = "10s"
  honor_labels = true
  honor_timestamps = true
  metrics_path = "/metrics"
  scheme = "http"
}

// Unix exporter for comprehensive system metrics
prometheus.exporter.unix "unix" {
  disable_collectors = [
    "ipvs",
    "infiniband",
    "xfs",
    "zfs",
  ]
  enable_collectors = [
    "cpu",
    "diskstats",
    "filefd",
    "filesystem",
    "hwmon",
    "interrupts",
    "ksmd",
    "loadavg",
    "logind",
    "meminfo",
    "mountstats",
    "netdev",
    "netstat",
    "processes",
    "sockstat",
    "stat",
    "systemd",
    "textfile",
    "time",
    "uname",
    "vmstat",
  ]
  filesystem {
    // Exclude mount points that aren't relevant for monitoring
    mount_points_exclude = "^/(dev|proc|run/credentials/.+|sys|var/lib/docker/.+)($|/)"
    // Exclude filesystem types that aren't relevant for monitoring
    fs_types_exclude     = "^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|tmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs)$"
    // Timeout for filesystem operations
    mount_timeout        = "5s"
  }
  netclass {
    // Ignore virtual and container network interfaces
    ignored_devices = "^(veth.*|cali.*|[a-f0-9]{15})$"
  }

  netdev {
    // Exclude virtual and container network interfaces from device metrics
    device_exclude = "^(veth.*|cali.*|[a-f0-9]{15})$"
  }
}

prometheus.scrape "unix" {
  targets = prometheus.exporter.unix.unix.targets
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  scrape_interval = "15s"
  scrape_timeout = "10s"
  honor_labels = true
  honor_timestamps = true
  metrics_path = "/metrics"
  scheme = "http"
}

// =============================================================================
// DISCOVERY COMPONENTS
// =============================================================================

// Discover all processes
discovery.process "all_processes" {
}

// Filter processes for monitoring
discovery.relabel "filtered_processes" {
  targets = discovery.process.all_processes.targets

  rule {
    action = "keep"
    regex = "^(prometheus|grafana|node_exporter|systemd_exporter|cadvisor|process_exporter|alloy)$"
    source_labels = ["__meta_process_name"]
  }
}

// Discover Docker containers for enhanced monitoring
discovery.docker "docker_containers" {
  host = "unix:///var/run/docker.sock"
  refresh_interval = "30s"
}

// Filter Docker containers for monitoring
discovery.relabel "filtered_docker_containers" {
  targets = discovery.docker.docker_containers.targets

  rule {
    action = "keep"
    regex = ".*"
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
  }

  rule {
    source_labels = ["__meta_docker_container_name"]
    target_label = "container_name"
  }

  rule {
    source_labels = ["__meta_docker_container_image"]
    target_label = "container_image"
  }

  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
    target_label = "service"
  }
}

// Discover log files dynamically
discovery.file "log_files" {
  files = [
    "/var/log/*.log",
    "/var/log/syslog",
    "/var/log/auth.log",
    "/var/log/kern.log",
    "/var/log/dmesg",
    "/var/log/daemon.log",
    "/var/log/messages",
    "/var/log/postgresql/*.log",
    "/var/lib/docker/containers/*/*.log",
    "/var/log/applications/*.log",
    "/opt/*/logs/*.log",
    "/var/log/audit/audit.log",
    "/var/log/fail2ban.log",
    "/var/log/ufw.log",
    "/var/log/iptables.log",
  ]
  refresh_interval = "60s"
}

// Filter discovered log files
discovery.relabel "filtered_log_files" {
  targets = discovery.file.log_files.targets

  rule {
    source_labels = ["__path__"]
    target_label = "file_path"
  }

  rule {
    source_labels = ["__filename__"]
    target_label = "filename"
  }

  rule {
    source_labels = ["__path__"]
    regex = ".*/([^/]+)\\.log"
    target_label = "service"
    replacement = "$1"
  }

  rule {
    source_labels = ["__path__"]
    regex = ".*/docker/containers/([^/]+)/.*"
    target_label = "container_id"
    replacement = "$1"
  }
}

// Process exporter for detailed process monitoring
prometheus.exporter.process "process" {
}

prometheus.scrape "process" {
  targets = discovery.relabel.filtered_processes.targets
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
  scrape_interval = "15s"
  scrape_timeout = "10s"
  honor_labels = true
  honor_timestamps = true
  metrics_path = "/metrics"
  scheme = "http"
}

// Filter DNS-discovered services
discovery.relabel "filtered_external_services" {
  targets = discovery.dns.external_services.targets

  rule {
    source_labels = ["__meta_dns_name"]
    target_label = "__param_target"
  }
  rule {
    source_labels = ["__meta_dns_name"]
    target_label = "instance"
  }
  rule {
    source_labels = ["__meta_dns_name"]
    target_label = "service_name"
  }
  rule {
    source_labels = ["__meta_dns_srv_record_target"]
    target_label = "target"
  }
}

// Blackbox exporter for probing endpoints
prometheus.exporter.blackbox "blackbox" {
  config_file = "/etc/alloy/blackbox.yml"
}

prometheus.scrape "blackbox" {
  targets = discovery.relabel.filtered_external_services.targets
  forward_to = [prometheus.remote_write.local.receiver]
  scrape_interval = "60s"
  scrape_timeout = "10s"
  honor_labels = true
  honor_timestamps = true
  metrics_path = "/probe"
  scheme = "http"
}

// cAdvisor exporter for container metrics
prometheus.exporter.cadvisor "cadvisor" {
  docker_host = "unix:///var/run/docker.sock"
  // Enhanced settings for server environment
  disable_metrics = [
    "accelerator",  // GPU metrics (usually not needed on servers)
    "disk_io",      // Can be noisy, enable if needed
  ]
  enable_metrics = [
    "cpu",
    "memory",
    "network",
    "disk",
    "processes",
    "tcp",
    "udp",
  ]
  // Container filtering for better performance
  container_hints = "/etc/cadvisor/container_hints.json"
  // Storage driver optimization
  storage_driver = "overlay2"
}

prometheus.scrape "cadvisor" {
  targets = prometheus.exporter.cadvisor.cadvisor.targets
  forward_to = [
    prometheus.remote_write.local.receiver,
  ]
}

// SNMP exporter for network devices
prometheus.exporter.snmp "snmp" {
  config_file = "/etc/alloy/snmp.yml"
  // Enhanced SNMP settings for network monitoring
  walk_params = {
    default = {
      version = "2c",
      auth_protocols = ["MD5", "SHA"],
      priv_protocols = ["DES", "AES"],
      retries = 3,
      timeout = "10s",
    },
  }
  // Optimize for network devices
  max_repetitions = 10
  retries = 3
  timeout = "10s"
}

prometheus.scrape "snmp" {
  targets = [
    {"__address__" = "1.1.1.1", "module" = "default"},
  ]
  forward_to = [prometheus.remote_write.local.receiver]
}

// DNS-based service discovery for external services
discovery.dns "external_services" {
  names = [
    "prometheus.io",
    "grafana.com",
    "google.com",
  ]
  refresh_interval = "300s"
  type = "A"
}


